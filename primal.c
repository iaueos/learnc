#include "stdio.h"
#include "string.h"
#include "stddef.h"

#define IDLE      0
#define TEST      1
#define NEAR      2
#define NUM       3
#define MAX       4
#define ASK       5
#define SPACE     6
#define TAB       7
#define PER       8
#define PAD       9
#define HELP     10
#define HINT     11

typedef unsigned long long NU;

unsigned char prima[] =
{ 2,  3,  5,  7, 11, 13, 17, 19, 23, 29,
 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
 73, 79, 83, 89, 97,101,103,107,109,113,
127,131,137,139,149,151,157,163,167,173,
179,181,191,193,197,199,211,223,227,229,
233,239,241,251};

NU primax = 251;

const char * cmd[] = {"",
"test","near","num","max","?",
"space","tab","per","pad","help", "hint"};

const char * help=
"primal <from> [<to>] <command>\n\
prints all primes numbers between <from> and <to>\n\
or do other operation in <command>\n\n\
PARAMeters:\n\
from : number more than 0 \n\
to   : number more than <from> \n\
command : do action of [test | near | num | max|space|tab|per <n>|pad<sn>]\n\n\
  test: test number <from>-upto <to> for primality, read stdin when no param\n\
  near: find near prime pattern 6n+1 6n-1 of numbers in param\n\
  num:  check if <from>,<to> is numeric, read stdin when no param \n\
  max:  show maximum number that can be checked\n\
  space:use space as separator\n\
  tab:  use tab as separator\n\
  per:  new line per <n> number,       default: 1\n\
  pad:  padleft number with <sn>space, default: 20\n\
\nusage:\n\
primal 1 10\n\n\
  prints prime number from 1 to 10\n";
const char * hints="\
\n\
number can be from 2 up to (2 power 64) - 1 = 18446744073709551615\n\
max prime output is                           18446744073709551557\n\
\n\n\
PRIME PATTERNs\n\n\
prime numbers bigger than 5 follows pattern of 6n+1 or 6n-1\n\
that pattern can be generated by adding 2 or 4 \n\
to prime to a number\n\n\
   5 + 2 =  7\n\
   7 + 4 = 11\n\
  11 + 2 = 13\n\
  13 + 4 = 17\n\
\n\
let's name this added number as 'a' \n\
\n\
when 'a' initially set to 2 or 10 in binary or 10b for short\n\
\n\
   2 (010b) xor(^) 6 (110b) \n\
   yields interesting        results\n\
\n\
   010b xor 110b = 100b  (2 ^ 6 = 4)\n\
   100b xor 110b = 010b  (4 ^ 6 = 2)\n\
\n\n\
a more detailed proof in primality test\n\
arrange numbers in 6 column \n\
\n\
   1   2   3   4   5   6\n\
   7   8   9  10  11  12\n\
  13  14  15  16  17  18\n\
  19  20  21  22  23  24\n\
  25  26  27  28  29  30\n\
  31  32  33  34  35  36\n\
\n\
notice that primes numbers greater than 5 \n\
always in the same columns as 1 and 5\n\
\n\
How?\n\
\n\
  column 2\n\
    has number with 6n+2 pattern\n\
    is not prime cause divisible by 2 \n\
    6n+2 = 2(3n+1)\n\
\n\
  column 3\n\
    has 6n+3 pattern\n\
    is not prime cause divisible by 3\n\
    6n+3 = 3(2n+1)\n\
\n\
  column 4\n\
    4 + (6n) = 2(2+3n)\n\
    divisible by 2\n\
\n\
  column 6\n\
    6n\n\
    divisible by 2 and 3\n\
\n\
the most likely candidate of prime always in column 1 and 5\n\
which has pattern of  6n+1 or 6n-1\n\
\n\
hence addition pattern after seed initiated is 2 or 4\n\
based on what columns prime seed falls into\n\
  column 5 add 2\n\
  column 1 add 4\n\
"
;
const char * LF="\n";
char * NUM_FMT ="llu";
char * numFormat = "%llu";
char * numSeparator = "\n";

/*
   check prime that is less than 255
 */
int isprime(unsigned char n)
{
    unsigned char a = 0;
    unsigned char b = sizeof(prima) / sizeof(prima[0]);

    int x = 0;

    while (a < b)
    {
        if (n == prima[a]) {
            x = 1;
            break;
        }
        a++;
    }
    return x;
}

NU maxval() {
    NU r= ~ ((NU)0);
    if (r<0)
        r=~((NU) 1 << ((sizeof(r) *8)-1));
    return (r);
}

int isPrime(NU n)
{
    int r = 0;
    NU f = 0;
    int i;
    if (n < primax + 2) {
        return isprime(n);
    } else {
        NU re = 1;
        NU m = primax + 2;
        unsigned short a = 4;
        NU d = 0;

        int j = sizeof(prima) / sizeof(prima[0]);
        // trial division of prime up to last prima[]
        for (i = 0; (i < j) && (re > 0); i++) {
            re = n % ((NU) prima[i]);
            if (re == 0)
            {
                f = prima[i];
                break;
            }
        }

        if (f != 0) {
            r = 0;
            return (r);
        }

        // trial division from 253 up to n
        f = 0;
        d = n;
        re = 1;
        while(re && (m < n) && (m < d))
        {
            d = n / m;
            re = n % m;

            if (re == 0) {
                f = m;
            }
            m += (NU) a;
            a = a ^ 6;
        }
        r = (f == 0);
    }
    return r;
}

NU near(NU x, unsigned char *a)
{
	NU r;
	r = x % 6;

	if (x < primax)
	{
		unsigned char b = sizeof(prima) / sizeof(prima[0]);

		int i;
		NU prev= prima[0];
		for (i=0;i<b ; i++) {
			if (prima[i]>x && (prev>x)) {
				x = prev;				
				break;
			}
			else if (prima[i]==x)
				break;
			else 
				prev = prima[i];			
		}
		*a = 1;
	} else {
		if (r <= 1)
		{
			x+= ((NU) 1-r);
			*a = 4;
		}
		else if (r>1)
		{
			x += ((NU) 5 - r);
			*a = 2;
		}
		while (!isPrime(x)) {
			x+=*a;
			*a^=6;
		}
	}
    return x;
}

int Per = 1;
int iPer = 0;

void say(NU l)
{
    if(iPer++>0)
        printf(numSeparator);

    printf(numFormat, l);

    if (Per>0 && iPer>=Per)
    {
        printf(LF);
        iPer = 0;
    }
}

NU value(char *instr)
{
  NU retval;
  int i;

  retval = 0;
  for (; *instr; instr++) {
    retval = ((*instr)>='0'&&(*instr)<='9')
           ? (10*retval + (NU) (*instr - '0'))
           : retval;
  }
  return retval;
}

int number(char *c)
{
    int r = 1;
    for(;*c && r;c++) {
        r = (*c>='0')&&(*c<='9');
    }
    return r;
}

int eol(char * c) {
    return (*c == '\n') || (*c == '\r');
}

void trimend(char *str) {
    char * sx = str;
    int i = 0;
    while(*sx && i<255) {
        if (*sx == '\n' || *sx=='\r')
            *sx = '\0';
        ++sx;
        ++i;
    }
}

void (*doit)(char * s);

void isnumy(char * s){
    if (number(s)) {
		if (iPer++> 0) printf(numSeparator); 
		
		printf("%s", s);
		
		if (Per>0 && iPer>=Per)
		{
			printf(LF);
			iPer = 0;
		}
    }
}

void nearby(char * s) {
    unsigned char rol = 0;
    NU n = 0;
    if (number(s)) {
        n = value(s);
        if (n!=0) {
            n = near(n, &rol);
            say(n);
        }
    }
}

int primaly(char * s) {
    NU z=0;
    if (number(s))
    {
        z = value(s);
        if (isPrime(z)) {
            say(z);
        }
    }
    return 0;
}

int main(int argc, char *argv[])
{
    NU i, x, y, z;
    unsigned char a = 0, b=0;
    int act = IDLE;
    int j = 0;
    char * t;
    char s[255];
    int pad = 20;
    j = sizeof(prima) / sizeof(prima[0]);     

    x=0;
    y=0;
    i=0;

    if (argc <= 1) {
        act = ASK;
    }

    for (a=1; a<argc; a++) {
        if (number(argv[a]))
        {
            if ((x==0)) {
                x = value(argv[a]);
            } else if ((y==0)) {
                y = value(argv[a]);
            }
        }
        else
        {
            t = argv[a];
            act = IDLE;
			int alen = sizeof(cmd) / sizeof(cmd[0]); 
            for (b=1; b< alen; b++) {
                if (strcmpi(t, cmd[b])==0)
                {
                    if (b == SPACE)
                    {
                        numSeparator= " ";
                    }
                    else if(b == TAB)
                    {
                        numSeparator = "\t";
                    }
                    else if(b == PER)
                    {
                        Per = (a<(argc-1))? value(argv[a+1]): -1;
                        a ++;
						if (Per < 0)  {							
							numSeparator = " ";
						}
						if (strcmp(numSeparator,LF)==0)
							numSeparator = "\t";
                    }
                    else if (b == PAD)
                    {
                        if ((a < argc-1) && number(argv[a+1]))
                        {
                            pad = value(argv[a+1]);
                            a++;
                        }
                        sprintf(s,"%%%d%s", pad, NUM_FMT);
                        strcpy(numFormat, s);
                    }
                    else
                    {
                        act = b;
                    }
                }
            }
        }
    }
    switch(act) {
        case TEST: doit = &primaly; break;
        case NEAR: doit = &nearby; break;
        case NUM:  doit = &isnumy; break;
        default:   doit = &primaly; break;
    }

    if ((act>=1) && (act<=3))
    {
        iPer = 0;

        for (a=1; a<argc; a++) {
            doit(argv[a]);
        }

        if (x==0 && y==0) {
            iPer = 0;
            while (fgets(s, sizeof s, stdin) != NULL && !eol(s)) {
                trimend(s);
                doit(s);
            }
        }
    } else if (act==MAX) {		
        say(maxval());		
    }
    if ((act==ASK)||(act==HELP)) {
        printf(help);
    }
    if (act==HINT)
        printf(hints);

    if (act > IDLE) 
		return(0);

    if ((x!= 0) && (y==0))
        y = maxval();

    i = x;
    a = 0;

    if (strcmp(numSeparator,LF)==0)
    {
        numSeparator = "\0";
    }
    iPer= 0;
    i = near(i, &a);

	int loops = 0;
	NU MAXLOOP = ((y-x)/3) + 20;
	
    while ((i <= y) && (i >= x) && (loops++<MAXLOOP)) {
        if (isPrime(i)) {
            say(i);
        } 
        		
		if (i < primax) {
			
			NU ii = near(i, &a);
			
			if (ii == i) {
				ii = near(i+1, &a);
			}
			i = ii;
			a = 1;
		}
		else  {
			i += a;
			a ^= 6;
		}
    }
}