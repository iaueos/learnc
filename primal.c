#include "stdio.h"
#include "string.h"
#include "stddef.h"

typedef unsigned long long NU;

unsigned char dv[] =
{ 2,  3,  5,  7, 11, 13, 17, 19, 23, 29,
 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
 73, 79, 83, 89, 97,101,103,107,109,113,
127,131,137,139,149,151,157,163,167,173,
179,181,191,193,197,199,211,223,227,229,
233,239,241,251};

const char * cmd[] = {"","test","near","num","max","?","space","tab","per","pad","help", "hint"};

const char * help=
"primal <from> [<to>] <command>\n\
prints all primes numbers between <from> and <to>\n\
or do other operation in <command>\n\n\
PARAMeters:\n\
from : number more than 0 \n\
to   : number more than <from> \n\
command : do action of [test | near | num | max|space|tab|per <n>|pad<sn>]\n\n\
  test: test number <from>-upto <to> for primality, read stdin when no param\n\
  near: find near prime pattern 6n+1 6n-1 of numbers in param\n\
  num:  check if <from>,<to> is numeric, read stdin when no param \n\
  max:  show maximum number that can be checked\n\
  space:use space as separator\n\
  tab:  use tab as separator\n\
  per:  new line per <n> number,       default: 1\n\
  pad:  padleft number with <sn>space, default: 20\n\
\nusage:\n\
primal 1 10\n\n\
  prints prime number from 1 to 10\n";
const char * hints="\
\n\
number can be from 2 up to (2 power 64) - 1 = 18446744073709551615\n\
max prime output is                           18446744073709551557\n\
\n\n\
PRIME PATTERNs\n\n\
prime numbers bigger than 5 follows pattern of 6n+1 or 6n-1\n\
that pattern can be generated by adding 2 or 4 \n\
to prime to a number\n\n\
   5 + 2 =  7\n\
   7 + 4 = 11\n\
  11 + 2 = 13\n\
  13 + 4 = 17\n\
\n\
let's name this added number as 'a' \n\
\n\
when 'a' initially set to 2 or 10 in binary or 10b for short\n\
\n\
   2 (010b) xor(^) 6 (110b) \n\
   yields interesting        results\n\
\n\
   010b xor 110b = 100b  (2 ^ 6 = 4)\n\
   100b xor 110b = 010b  (4 ^ 6 = 2)\n\
\n\n\
a more detailed proof in primality test\n\
arrange numbers in 6 column \n\
\n\
   1   2   3   4   5   6\n\
   7   8   9  10  11  12\n\
  13  14  15  16  17  18\n\
  19  20  21  22  23  24\n\
  25  26  27  28  29  30\n\
  31  32  33  34  35  36\n\
\n\
notice that primes numbers greater than 5 \n\
always in the same columns as 1 and 5\n\
\n\
How?\n\
\n\
  column 2\n\
    has number with 6n+2 pattern\n\
    is not prime cause divisible by 2 \n\
    6n+2 = 2(3n+1)\n\
\n\
  column 3\n\
    has 6n+3 pattern\n\
    is not prime cause divisible by 3\n\
    6n+3 = 3(2n+1)\n\
\n\
  column 4\n\
    4 + (6n) = 2(2+3n)\n\
    divisible by 2\n\
\n\
  column 6\n\
    6n\n\
    divisible by 2 and 3\n\
\n\
the most likely candidate of prime always in column 1 and 5\n\
which has pattern of  6n+1 or 6n-1\n\
\n\
hence addition pattern after seed initiated is 2 or 4\n\
based on what columns prime seed falls into\n\
  column 5 add 2\n\
  column 1 add 4\n\
"
;
const char * LF="\n";
char * NUM_FMT ="llu";
char * numFormat = "%llu";
char * numSeparator = "\n";

/*
   check prime that is less than 255
 */
int isprime(unsigned char n)
{
    unsigned char a = 0;
    unsigned char b = sizeof(dv) / sizeof(dv[0]);

    int x = 0;

    while (a < b)
    {
        if (n == dv[a]) {
            x = 1;
            break;
        }
        a++;
    }
    return x;
}

NU maxval() {
    NU r= ~ ((NU)0);
    if (r<0)
        r=~((NU) 1 << ((sizeof(r) *8)-1));
    return (r);
}

int isPrime(NU n)
{
    int r = 0;
    NU f = 0;
    int i;
    if (n < 253) {
        return isprime(n);
    } else {
        NU re = 1;
        NU m = 253;
        unsigned short a = 4;
        NU d = 0;

        int j = sizeof dv;
        // trial division of prime up to last dv[]
        for (i = 0; (i < j) && (re > 0); i++) {
            re = n % ((NU) dv[i]);
            if (re == 0)
            {
                f = dv[i];
                break;
            }
        }

        if (f != 0) {
            r = 0;
            return (r);
        }

        // trial division from 253 up to n
        f = 0;
        d = n;
        re = 1;
        while(re && (m < n) && (m < d))
        {
            d = n / m;
            re = n % m;

            if (re == 0) {
                f = m;
            }
            m += (NU) a;
            a = a ^ 6;
        }
        r = (f == 0);
    }
    return r;
}

NU near(NU x, unsigned char *a)
{
    NU r;
    r = x % 6;
    if (r <= 1)
    {
        x+= ((NU) 1-r);
        *a = 4;
    }
    else if (r>1)
    {
        x += ((NU) 5 - r);
        *a = 2;
    }
    return x;
}

int Per = 1;
int iPer = 0;

void say(NU l)
{
	if(iPer>0)
		printf(numSeparator);

    printf(numFormat, l);	
	
	if (++iPer>=Per) 
	{	
		printf(LF);		
		iPer = 0;
	}
}

NU num(char *instr)
{
  NU retval;
  int i;

  retval = 0;
  for (; *instr; instr++) {
    retval = ((*instr)>='0'&&(*instr)<='9')
           ? (10*retval + (NU) (*instr - '0'))
           : retval;
  }
  return retval;
}

int isnum(char *c)
{
    int r = 1;
    for(;*c && r;c++) {
        r = (*c>='0')&&(*c<='9');
    }
    return r;
}

int isend(char * c) {
    return (*c == '\n') || (*c == '\r');
}

void trimend(char *str) {
    char * sx = str;
    int i = 0;
    while(*sx && i<255) {
        if (*sx == '\n' || *sx=='\r')
            *sx = '\0';
        ++sx;
        ++i;
    }
}

void (*doit)(char * s);



void isnumy(char * s){
    if (isnum(s)) {				
        printf("%s", s);		
	}
}

void nearby(char * s) {
    unsigned char rol = 0;
    NU n = 0;
    if (isnum(s)) {
        n = num(s);
        if (n!=0) {
            n = near(n, &rol);
            say(n);			
        }
    }
}

int primaly(char * s) {
    NU z=0;
    if (isnum(s))
    {
        z = num(s);
        if (isPrime(z)) {
            say(z);
		}
    }
}

int main(int argc, char *argv[])
{
    NU i, x, y, z;
    unsigned char a = 0, b=0;
    int act = 0;
    int j = 0;
    char * t;
    char s[255];
	int pad = 20;
	j = sizeof dv;
	NU dvMax = (NU) dv[j-1];
	// printf("dv length:%d  dv Max:%llu\n", j, dvMax );
    x=0;
    y=0;
    i=0;

    if (argc <= 1) {
        act = 5;
    }

    for (a=1; a<argc; a++) {
        if (isnum(argv[a]))
        {
            if ((x==0)) {
                x = num(argv[a]);
            } else if ((y==0)) {
                y = num(argv[a]);
            }
        }
        else
        {
            t = argv[a];
            act= 0;
            
            for (b=1; b<cmd.length; b++) {
                if (strcmpi(t, cmd[b])==0)
                {
					if (b == 6)
					{
						numSeparator= " ";
						
					}
					else if(b == 7)
					{
						numSeparator = "\t";
					}
					else if(b == 8) 
					{
						Per = (a<(argc-1))? num(argv[a+1]): 1;
						a ++;
						
						if (strcmp(numSeparator,LF)==0)
							numSeparator = "\t";
					}
					else if (b==9)
					{
						if ((a < argc-1) && isnum(argv[a+1]))
						{
							pad = num(argv[a+1]);
							a++;
						}
						sprintf(s,"%%%d%s", pad, NUM_FMT);
						strcpy(numFormat, s);
						
					}
					else 
					{
						act = b;                    
					}					
                }
            }			
        }
    }

    switch(act) {
        case 1: doit = &primaly; break;
		case 2: doit = &nearby; break;
		case 3: doit = &isnumy; break; 
		default: doit = &primaly; break;
	}
		
	if ((act>=1) && (act<=3))
	{
		iPer = 0;
		
		for (a=1; a<argc; a++) {
			doit(argv[a]);
		}

		if (x==0 && y==0) {
			iPer = 0;
			
			while (fgets(s, sizeof s, stdin) != NULL && !isend(s)) {
				trimend(s);
				doit(s);
			}
		}
	} else if (act==4) {		
		say(maxval());
	} 
    if ((act==5)||(act==10)) {
        printf(help);
    }
    if (act==11)
        printf(hints);
    
    if (act > 0) return(0);

    if ((x!= 0) && (y==0))
        y = maxval();

    i = x;
    a = 0;
	
	if (strcmp(numSeparator,LF)==0) 
	{
		numSeparator = "\0";
	}
	iPer= 0;
    while ((i <= y) && (i <= dvMax) && (i>=x))
    {
        if (isprime(i)) {			
            say(i);
            if (i>3) i++;
        }
        ++i;
    }
    i = near(i, &a);

    while ((i <= y) && (i >= x)) {
        if (isPrime(i)) {
            say(i);
		}
        i += a;
        a ^= 6;
    }

}